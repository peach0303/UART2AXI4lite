module UART_TX (
    input            clk,
    input            rst_n,
    input            odd_parity,
    input [7:0]      data_in,       // Òª·¢ËÍµÄ8Î»Êý¾Ý
    input            start,         // ¿ªÊ¼·¢ËÍµÄÐÅºÅ
    output reg       uart_tx,            // ´®ÐÐÊä³öÐÅºÅ
    output reg       data_ready     // ·¢ËÍÍê³ÉÐÅºÅ
);

parameter IDLE = 1'b0;
parameter SEND = 1'b1;

reg state, next_state;              
reg [7:0] data, next_data;           
reg [2:0] bit_cnt, next_bit_cnt;     
reg next_data_ready;                 


always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        state <= IDLE;
        data <= 8'b0;
        bit_cnt <= 3'd0;
        data_ready <= 1'b1;          
        uart_tx <= 1'b1;                  
    end else begin
        state <= next_state;
        data <= next_data;
        bit_cnt <= next_bit_cnt;
        data_ready <= next_data_ready;
    end
end


always @(*) begin
    
    next_state = state;
    next_data = data;
    next_bit_cnt = bit_cnt;
    next_data_ready = 0;
    uart_tx = 1'b1;  

    case (state)
        IDLE: begin
            if (start) begin
                next_state = SEND;
                next_data = data_in;         
                next_bit_cnt = 3'd0;        
                next_data_ready = 1'b0;     
            end
        end
        
        SEND: begin
                uart_tx = data[0];                
                next_data = data >> 1;       
                next_bit_cnt = bit_cnt + 1;  
                if (bit_cnt == 3'd7) begin   
                    next_state = IDLE;
                    next_data_ready = 1'b1;  
                end
            
        end
        default: next_state = IDLE;         
    endcase
end

endmodule

